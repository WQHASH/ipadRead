<script type="text/javascript">
		
	/**
	 * [description: 2.2欺骗词法]
	 *  eval用法: eval()函数接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码
	 *  		  在执行eval()之后的代码时，引擎并不知道或在意前面的代码是以动态形式插入进来的，
	 *  		  并对词法作用域的环境进行修改。引擎只会如往常的进行词法作用域查询。	
	 */
	(function(){
		function foo(str, a){
			eval(str);
			// console.log(a, b);
		}	
		var b = 2;
		var ev=b+3;
		foo("var b = "+ ev, 1);
	})();

	/**
	 * [description new Function()]
	 * 最后一个参数最为函数体，前面的为参数，
	 * 相比较eval略微安全些，但都避免使用，因为它们所带来的好处无法抵消性能上的损失。
	 */
	(function(){
		var fun = new Function("a","return a");
		// console.log(fun(2), "fun");
	})();


	/**
	 * 小结：
	 * 		词法作用域: 词法作用域意味着作用域是由于书写代码时函数声明的位置决定的。
	 * 			    	编译的词法分析阶段基本上能够知道变量在哪声明，从而能在执行时对他们进行查找
	 * 			    	
	 * 		欺骗词法: eval && with
	 * 			 根据上边的说的基本上作用域可以确定作用域，但是碰到eval with	作用域可能会改变
	 * 			 不推荐使用：  这两种机制带来的副作用是引擎无法再编译时对作用域查找进行优化， 
	 * 			 				因为不能确定 eval中会接收到什么代码。   	
	 */


	


</script>