<script type="text/javascript">
	/**
	 * 2.1 调用位置
	 */
	(function () {
		/**
		 * 理解 游览器调试调用栈方法
		 */

		var obj = {
			sname: "wq"
		};

		function baz() {
			console.log("baz");
			bar();
		};

		function bar() {
			console.log("bar");
			foo();
		};

		function foo() {
			console.log("foo");
		};
		// baz();


	})();

	/**
	 * 2.2.2  隐式绑定， this隐式丢失问题
	 * 隐式绑定: 理解什么是隐式绑定，存在对象调用方法 此时this则会指向当前调用方法的对象
	 */
	(function () {
		function foo() {
			console.log(this.a);
		};
		var obj = {
			a: 2,
			foo: foo,
		};
		// obj.foo();

	})();



	/**
	 * 2.2.2  隐式绑定， this隐式丢失问题
	 */

	(function () {

		var obj = {
			sname: "wq",
			say: function () {
				return this.sname;
			}
		};
		window.sname = "wangqi";
		var say = obj.say;
		// console.log(say());

	})();

	/**
	 *  隐式丢失问题  (参数传递[回调函数] 就是一种隐式赋值)
	 */

	(function () {

		function foo() {
			console.log(this.a);
		};

		function doFoo(fn) {
			fn();
		};
		var obj = {
			a: 2,
			foo: foo,
		};
		window.a = "gloabl";
		// doFoo(obj.foo);
	})();

	/**
	 * 2.2.3 显示绑定
	 *  显示绑定: 手动的修改绑定  可使用 apply call bind  实现
	 *  注意apply call的参数传递： 
	 *  	第一个参数是一个对象，如果传入一个原始值，这个原始值会被隐式转换（new String）成对象。
	 *  	此时的this则就是隐=隐式转换的对象值，如果是 null,undefined则会采用默认绑定规则 => 指向window
	 */
	(function () {
		function foo() {
			console.log(this);
		}
		var obj = {
			c: 2,
		};
		// foo.call(23);  // Number {23}
	})();

	/**
	 * 2.3 优先级
	 * this绑定机制的方式以及他们的优先级:
	 * 		new > 显示绑定 > 隐式绑定 >  默认绑定
	 *   	new: new的通过构造函数创建一个新对象方式， 配合理解bind方法中 处理是否new的机制。
	 *    	显示绑定:  bind方法系列，如直接修改当前绑定的对象 apply  call。
	 *     	隐式绑定:  其实就是对象中存在方法属性，然后直接调用。 注意的是 this可能存在丢失的情况!!
	 *      默认绑定:  函数中的this默认会指向window。
	 */

	(function () {
		function foo(something) {
			this.a = something;
		};
		var obj1 = {
			foo: foo,
		};
		var obj2 = {};
		obj1.foo(2);
		// console.log(obj1.a);

	})();

	/**
	 * 2.4.1  被忽略的this
	 */

	(function () {
		// Object.create() 和  {}  new OBj() 的区别

		/**
		 * new的过程：
		 *  function Fun(){};
		 *  var f = new Fun();
		 *
		 *	1. var f = {};
		 *	2. f.__proto__ = Fun.prototype;
		 *	3. Fun.apply(f);
		 * 
		 */

		/**
		 * Object.create() 的过程:
		 */

		function create(PROTOTYPE) {
			function fun() {};
			fun.prototype = PROTOTYPE;
			return new fun();
		};


		// 理解绑定参数的区别:
		// 	总是用null来忽略this可能会产生副作用，
		function foo(arg) {
			// console.log(this, arg+"==foo-this");
		};
		var obj = {
			foo: foo,
			sname: "Wq"
		}

		obj.foo(this, "foo"); // obj
		obj.foo.call(null, "call-null"); // window	
		obj.foo.call(undefined, "call-undefined"); // window
		obj.foo.call({}, "{}"); // {}
		// {}  同{}参数比较不同的是，这个创建空对象不会创建 Object.prototype这个委托，所以比 {} 更空
		obj.foo.call(Object.create(null), "{}");

	})();

	
	(function () {

	})();
</script>