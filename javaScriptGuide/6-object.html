<script type="text/javascript">
	/**
	 * 6.1.2通过new创建对象
	 */
	(function(){
		/**
		 *  1. 创建了一个新对象，  var fun = {}
		 *  2. 将构造函数的作用域赋给新值(因此this就指向了这个新对象)  fun.__proto__=Fun.prototype
		 *     因为每个对象都从原型继承属性, 这里把fun空对象的__proto__指向Fun.prototyep	 如果直接var声明的那么他将继承 Object.prototype
		 *  3. 执行构造函数中的代码（为这个新对象添加属性）call的用法把Fun的this指向了fun  Fun.call(fun)
		 *  4. 返回新对象   
		 */
		function Fun(){}
		var fun = new Fun();


		//======== ******************************============
		//======== ******************************============
		// 关于Object.create() 方法剖析:
		// Object.defineProperties 和 Object.defineProperties 的理解： https://segmentfault.com/a/1190000011294519
		// defineProperties[用来设置是否可枚举属性] defineProperties[最原生的增加属性方法]
		// 											***new实现方法剖析:  http://www.php.cn/js-tutorial-379371.html 
		//  Object.getPrototypeOf(obj) => 通锅obj.__proto__属性找到obj的上一级也就是其原型对象											
		//======== ******************************============
		//======== ******************************============
		// Object.create = function(prototype, properties){
		// 	if(typeof prototype !== "object"){
		// 		throw new Error();
		// 	}
		// 	var obj = {};
		// 	obj.__proto__ = prototype;
		// 	if(typeof properties !== "undefined"){
		// 		//这里和new 的过程不同的是: new 的要构造函数，然后在新对象调用时借用构造里边的方法，
		// 		//而Object.create的方法是通过第二个参数来手动设置的。
		// 		Object.defineProperties(obj, properties);
		// 	}
		// 	return obj; 
		// };


	})();


	/**
	 * ?? 对象创建遗留问题，需画图
	 * 手写bind: https://blog.csdn.net/qq_40479190/article/details/78324282
	 */

	(function(){
		function Ctor(){};
		var baseCreate = function(prototype){
	        Ctor.prototype = prototype;
	        var result = new Ctor();

	        console.log(Ctor.prototype,"xx"); // {"sname":21}
	        Ctor.prototype = null;
	        console.log(result.__proto__,"yy");  // {{"sname":21}}
	        return result; 
	    };
	    var obj = baseCreate({"sname":"21"});
	    // 两次打印的值为什么还相等呢？
	    // 不太明白，为什么 Ctor.prototype = null; 赋值为null后 
	    // 实例result。__proto__还能找到 Ctor.prototype这个值，难道 result.__proto__指向的是另一份对象？
	    // 已解决： 记住赋值的关系是把后边赋值给前边 ====>var a=[1];var b=a; a =[2]; b // [1]

	})();


	/**
	 * 6.2.2继承
	 */

	(function(){
		function inherit(p){
			if(p == null){ throw TypeError()};
			if(Object.create){
				return Object.create(p);
			};
			var t = typeof p;
			if(t !== "object" && t!=="function"){ throw TypeError() };
			function f(){};
			f.prototype = p;
			return new f();
		};

		// var o = {};
		function O(){
			this.x =1;
		};
		var o = new O();

		// 理解: 这里的参数，其实就是传递一个对象，来找熟悉 (别说传原型，因为传原型，原型又会指向构造函数，这样属性就没法用了)
		// o.x = 1;
		var p = inherit(o);
		p.y = 2;
		var q = inherit(p);
		q.z = 3;
		var s = q.toString();
		q.x=2;
		var num = q.x + q.y;
		console.log(q,"q");
		console.log(num,"num");

	})();


</script>